Прямая, по которой движется объект на плоскости  задается уравнением  kx + b.
Пусть у меня есть функция (ции), которая определяет, пересечется ли на следующем шаге (изменении) точка с (отрезком) прямой, 
задаваемой уравнением x = N  или y = N.

мне необходим также параметр, определяющий направление по прямой kx + b. Назову его v

все объекты с которыми может столкнуться шар имеют прямоугольную форму, значит при столкновении достаточно просто умножить k на -1, если
 только шарик не ударился об угол объекта. Если не ударился об угол, значит это "простое столкновение".

Но, при простом столкновении необходимо определить, с каким отрезком прямой, горизонтальным или вертикальным  происходит столкновение, 
так как от этого зависит, изменит ли знак v.

Все пространство поделено на квадраты.
Перед каждым изменением координат объект смотрит, в каком квадрате он окажется.

Есть ли еще в этом квадрате объекты?
Если да, для каждого проверить принадлежит ли новое положение одному из объектов

Первым делом проверяю простое столкновение со сторонами кирпича, то есть те случаи, когда новые координаты центра шарика
входят в пределы отрезка прямой, определяющей сторону объекта:

Для горизонтальной стороны: if (ball.gx() >= brick.x && ball.gx() <= brick.x + brick.w && ball.gyh(brick) )

 где gx работает так:
  return this.x + this.dx + this.w / 2;
   
 
  где gyh работает так:
  gyh(brck) {
    var p1 = this.k * this.gx() + this.b - this.h / 2,
        p2 = this.k * this.gx() + this.b + this.h / 2,
        b = brck;
    if (
         (b.y > p1.y && b.y < p1.y + p1.h)
      || (b.y > p2.y && b.y < p2.y + p1.h)
    ) {
      return true;
     }
    return false;
  }

  
Для вертикальной стороны : if (ball.gy() >= brick.y && ball.gy() <= brick.y + brick.h && ball.gxw(brick) )

 где gy работает так:
  return this.k * (this.x + this.dx + this.h / 2) + this.b;
   
  gxw(brck) {
    var p1 = this.x + this.dx + this.w / 2;
    var p2 = this.x + this.dx - this.w / 2;
    
    var b = brck;
    if (
      (b.x > p1.x && b.x < p1.x + p1.w)
      || (b.x > p2.x && b.x < p2.x + p1.w)
    )
    return true;
    return false;
  }

Если простое столкновение произошло, надо откорректировать тяжелый случай (см. N для сложного столкновения  

  см. model_delta_s.svg
    Пусть C центр шара, D точка пересечения радиуса со стороной (если сторона горизонтальная - с вертикальной и наоборот)
     и K - точка пересечения направляющей и стороны. Определив CD  и CK вычисляю CK.
     
    N = CK;
    Далее, от ball.cx отнимаем N  ип пересчитываем ball.cy.
    
    После того, как получен новый k 
    ball.cx += N; ball.cy = F(ball.cx);
 

  
Если простое столкновение не произошло, проверяю расстояние от центра шара до прямых, на которых лежат стороны прямоугольника

Если расстояние меньше или равно радиусу, проверяю расстояние от центра шара до углов прямоугольника.
 Если среди них найден угол (точка), до которой расстояние меньше равно радиусу, значит осталось вычислить новые k и b.
 
  Но! если расстояние меньше радиуса... 
    У нас есть расстояние CU (от центра до угла по оси x). вычтем его из R  и называем N, а текущий ball.cx = ball.cx - N
    персчитываем игрек и далее работаем с ними, запомнив N. 
    N - это то расстояние, на которое должен сместиться шар по оси икс после столкновения
 
 снаала нахожу нормаль к радиусу от центра до угла.
  далее,  (!! не уверен до конца, но пожалуй сделаю)
  беру три точки, центр (C), угол прямоугольника (U) и точку пересечения нормали и текущего направления (D).
  Нахожу точку K на прямой CD такую ,что UCD = CUK ( использую равнобедренный треугольник)
  смещаю координаты K:
     K.x += D.x - C.x;
     K.y += D.y - C.y;
  Получаю коэффициенты  прямой, проходящей через CK (после смещения !)
  Это и есть наши новые k и b.
  Но, важно разобраться с v.
  если исходная направляющая  пересекается с вертикальной стороной, знак v меняется.
  
  Далее, если N определено прибавляем к ball.cx N*v  и пересчитываем ball.cу
  
  (/ !!)
  
      
Итого, получается примерно так.

//var sqIndex = this.getNextSquareIndex(ball);
//var objectList = this.map[sqIndex];
var objectList = this.getNextStepBricks(ball); //меняю предыдущие два на это, так как шар может быть в нескольких (до 4-ех) квадратах сразу

if (objectList.prototype.constructor == Array) {
    var sz = objectList.length, i, success = 0;
    for (i = 0; i < sz; i += 1) {
        if ( ball.hitTest(objectList[i]) ) {
	    success = 1;
	    break;
        }
    }
    if (!success) {
        ball.move();
    }
}
/*
Изменяет параметры движения dx, k, b, v,
return true если изменил или false если не изменил
*/
hitTest(mc) {
    var obj = {},
    res = this.superclass.hitTest(mc, true, obj); //Наследуем CBall от Sprite. obj содержит данные 
    /*
    {
      type: 0|1|2, //0 - не пересекается, 1 - касается, 2 - пересекается
      sides : [1, 0, 0, 1], //стороны клипа mc которые пересекают стороны клипа this. top (в примере - пересекет), right (не пересекает), bottom (не пересекает), right (пересекает) 
      vector : [1, 0, 0, 1], //направление вектора от центра this к центру mc (направлен сверху  вниз|справо налево|снизу вверх|слева направо)
      belong : "w", // "w" - центр this принадлежит интервалу mc.x ... mc.x + mc.width, "h" - принадлежит интервалу mc.y ... mc.y + mc.height, "" 
                    // не принадлежит интервалам, "wh" - принадлежит обоим интервалам (центр this внутри области mc)
      
    }
    */
    if (obj.type) {
	if (obj.belong == "w" /*|| obj.belong == "h"*/) {
	    //простое столкновение по горизонтали
	    if (obj.vector[0] == 1) {
	        //проверить для верхнего, возможно тут же сдвинуть и откорректировать
	    }
	    if (obj.vector[2] == 1) {
	        //проверить для нижнего, возможно тут же сдвинуть и откорректировать
	    }
	}
	//далее то же для вертикалей
	// ююю ююю ... ... ююю ююю 
	
	//если сюда дошли, значит простое столкновение не произошло
	//проверяем для левой верхней вершины mc и далее по часовой
	ша 
    }
    
}
---------------------------------------- 
